\documentclass[12pt]{article}

\usepackage[utf8x]{inputenc}
\usepackage[T1, T2A]{fontenc}
\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage{listings} 
\usepackage[english,russian]{babel}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{indentfirst}
\usepackage{ulem} 
\usepackage{ulem} 
\usepackage{caption}

\usepackage{fancyhdr} 
\usepackage{subcaption}
\usepackage{listings} 
\usepackage{noindentafter}
\usepackage{indentfirst}

\parindent=1cm
\makeatletter
\newcommand{\rindex}[2][\imki@jobname]{%
    \index[#1]{\detokenize{#2}}%
}
\makeatother
\newcolumntype{P}[1]{>{\raggedbottom\arraybackslash}p{#1}}

\linespread{1}
\pgfplotsset{compat=1.16}
\newcommand{\ttitle}[1]{
    %\begin{titlepage}
    \newpage
        \begin{center}
            \bfseries
            
            {\Large Московский авиационный институт\\ (национальный исследовательский университет)
                
            }
            
            \vspace{48pt}
            
            {\large Факультет информационных технологий и прикладной математики
            }
            
            \vspace{36pt}
            
            
            {\large Кафедра вычислительной математики и~программирования
                
            }
            
            
            \vspace{48pt}
            
            Отчёт по лабораторной работе №#1
        
        \end{center}

        \vspace{72pt}

    \begin{flushright}
        \begin{tabular}{rl}
            Студент: & П.\, А. Милько \\
            Преподаватель: & А.\, В. Поповкин \\
            Группа: & М8О-208Б-17 \\
            Дата: & \\
            Оценка: & \\
            Подпись: & \\
        \end{tabular}
    \end{flushright}
    
    \vfill
    
    \begin{center}
        \bfseries
        Москва\\
        \the\year
    \end{center}
    
    %\end{titlepage}
\pagebreak
}

\newcommand{\se}[1]{\section*{#1}}

\newcommand{\var}{\se{Вариант
    \textbf{\large {17 :}}}
\noindent     \begin{tabular}{ll}
    \textit{Фигуры}: &Треугольник, квадрат, прямоугольник\\
    \textit{Первый контейнер}: &Бинарное дерево \\
    \textit{Второй контейнер}: &Очередь    
    \end{tabular}

}

\newcommand{\lst}[2]{
    \subsection*{\textbf{#2}}
{    \scriptsize
    \lstinputlisting[language=c++]{#1/#2}}
}
 \fancyfoot[C]{\thepage}
\begin{document}

\begin{center}
	\bfseries

	{\Large Московский авиационный институт\\ (национальный исследовательский университет)

	}

	\vspace{48pt}

	{\large Факультет информационных технологий и прикладной математики
	}

	\vspace{36pt}


	{\large Кафедра вычислительной математики и~программирования

	}


	\vspace{48pt}

	{Отчёт по лабораторным работам по курсу: \\
		Объектно-ориентированное программирование}

\end{center}

\vspace{72pt}

\begin{flushright}
	\begin{tabular}{rl}
		Студент:       & П.\, А. Милько   \\
		Преподаватель: & А.\, В. Поповкин \\
		Группа:        & М8О-208Б-17      \\
		Дата:          &                  \\
		Оценка:        &                  \\
		Подпись:       &                  \\
	\end{tabular}
\end{flushright}

\vfill

\begin{center}
	\bfseries
	Москва\\
	\the\year
\end{center}

\ttitle{1}
\fancyfoot[C]{\thepage}
\var
\se{Цель работы}
\begin{itemize}
	\item  Программирование классов на языке С++
	\item     Управление памятью в языке С++
	\item     Изучение базовых понятий ООП.
	\item Знакомство с классами в C++.
	\item     Знакомство с перегрузкой операторов.
	\item     Знакомство с дружественными функциями.
	\item     Знакомство с операциями ввода-вывода из стандартных библиотек.
\end{itemize}

\se{Задание}
\noindent
Необходимо спроектировать и запрограммировать на языке C++ классы фигур, согласно
вариантов задания.
Классы должны удовлетворять следующим правилам:
\begin{itemize}
	\item  Должны иметь общий родительский класс Figure.
	\item  Должны иметь общий виртуальный метод Print, печатающий параметры фигуры и ее
	      тип в стандартный поток вывода cout.
	\item  Должный иметь общий виртуальный метод расчета площади фигуры – Square.
	\item Должны иметь конструктор, считывающий значения основных параметров фигуры из
	      стандартного потока cin.
	\item Должны быть расположенны в раздельных файлах: отдельно заголовки (.h), отдельно
	      описание методов (.cpp).
	\item Программа должна позволять вводить фигуру каждого типа с клавиатуры, выводить
	      параметры фигур на экран и их площадь.
\end{itemize}

\se{Исходный код}

\lst{lab00}{Figure.hpp}
\lst{lab00}{Triangle.hpp}
\lst{lab00}{Triangle.cpp}
\lst{lab00}{Rectangle.hpp}
\lst{lab00}{Rectangle.cpp}
\lst{lab00}{Sqr.hpp}
\lst{lab00}{Sqr.cpp}
\lst{lab00}{main.cpp}

\se{Демо}
{\scriptsize
	\begin{lstlisting}
Create Triangle:
Insert a, b, c >> 1 2 2
a=1, b=2, c=2
Square = 0.968246

Create Square:
Insert a >> 4
a=4
Square = 16

Create Rectangle:
Insert a, b >> 2 4
a=2, b=4
Square = 8

Triangle deleted
Sqr deleted
Rectangle deleted
\end{lstlisting}}

\se{Выводы}

Я приобрел навыки проектирования классов и работы с ними. Фундаментальные концепции ООП инкапсуляция, наследование и полиморфизм также отражены в моей работе. Инкапсуляция в виде разделения интерфейса (печать параметров фигуры и подсчет площади) и реализации (параметры фигуры), наследование в виде производных классов Triangle, Square и Rectangle от класса Figurе, полиморфизм в виде переопределении методов Print и Square. Удобно использовать объекты, не задумываясь о внутренней реализации.

\ttitle{2}

\var

\se{Цель работы }

\begin{itemize}
	\item Закрепление навыков работы с классами.
	\item Создание простых динамических структур данных.
	\item Работа с объектами, передаваемыми «по значению».
\end{itemize}

\se{Исходный код}

\lst{lab01}{Figure.hpp}
\lst{lab01}{Triangle.hpp}
\lst{lab01}{Triangle.cpp}
\lst{lab01}{TTree.hpp}
\lst{lab01}{TTree.cpp}
\lst{lab01}{main.cpp}

\newpage
\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:            + side_a side_b side_c
Delete element:         - path
path={r,l}*
Get element:            g path
path={r,l}*

command>> + 1 2 2
______________________________________________
(1,2,2)
command>> + 1 1 1
______________________________________________
(1,2,2)<
    (1,1,1)
command>> + 2 2 2
______________________________________________
    (2,2,2)
(1,2,2)<
    (1,1,1)
command>> + 3 3 3
______________________________________________
        (3,3,3)
    (2,2,2)<
(1,2,2)<
    (1,1,1)
command>> - l
______________________________________________
        (3,3,3)
    (2,2,2)<
(1,2,2)
command>> - rr
______________________________________________
    (2,2,2)
(1,2,2)<
command>> - l
______________________________________________
(2,2,2)
command>> 
\end{lstlisting}}

\se{Выводы}

В данной лабораторной работе я получил навыки программирования классов на языке С++, а так же познакомился с перегрузкой операторов и дружественными функциями. Язык позволяет создавать умные классы-контейнеры, для хранения и обработки большого количества объектов одного типа. Сами объекты могут хранится последовательно
или в разных частях памяти. Достоинство языка C++ заключается в том что мы можем абстрагироваться от сложностей реализации нашей структуры: когда класс структуры уже описан, у нас получается простой и безопасный интерфейс для работы со с контейнером.


\ttitle{3}
\var

\se{Цель работы}

\begin{itemize}
	\item  Закрепление навыков работы с классами.
	\item Знакомство с умными указателями.

\end{itemize}

\se{Исходный код}

\lst{lab02}{Figure.hpp}
\lst{lab02}{Triangle.hpp}
\lst{lab02}{Triangle.cpp}
\lst{lab02}{Rectangle.hpp}
\lst{lab02}{Rectangle.cpp}
\lst{lab02}{Sqr.hpp}
\lst{lab02}{Sqr.cpp}
\lst{lab02}{TTree.hpp}
\lst{lab02}{TTree.cpp}
\lst{lab02}{Tree.hpp}
\lst{lab02}{Tree.cpp}
\lst{lab02}{main.cpp}

\se{Демо}

{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + {t,r,s} side_a side_b side_c
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*

command>> +t  1 2 2        
____________________________________________
(1,2,2)
command>> +r 2 4
____________________________________________
    (2,4)
(1,2,2)<
command>> +s 9
____________________________________________
        (9)
    (2,4)<
(1,2,2)<
command>> +t 1 1 1
____________________________________________
    (9)
    (2,4)<
(1,2,2)<
    (1,1,1)
command>> +s 1
____________________________________________
        (9)
    (2,4)<
        (1)
(1,2,2)<
    (1,1,1)
command>> + r 1 1 
____________________________________________
        (9)
    (2,4)<
            (1,1)
        (1)<
(1,2,2)<
    (1,1,1)
command>> - l
____________________________________________
        (9)
    (2,4)<
            (1,1)
        (1)<
(1,2,2)<
command>> - l
____________________________________________
        (9)<
                (1,1)
            (1)<
(2,4)<
command>> - rlr
____________________________________________
        (9)<
            (1)
(2,4)<
command>> 
\end{lstlisting}
}

\se{Выводы}

Умные указатели, помимо того что заменяют сборщики мусора, позволяют хранить указатели на абстрактные классы, таким образом можно создавать контейнеры, которые могут хранить элементы разных классов. При правильной работе с умными указателями, можно не задумываться об очистке памяти. Работать с умными указателями достаточно просто и удобно. Только важно знать про разные типы умных указателей, и применять их в наиболее подходящих ситуациях.


\ttitle{4}

\var

\se{Цель работы}

\begin{itemize}
	\item  Знакомство с шаблонами классов.
	\item Построение шаблонов динамических структур данных.

\end{itemize}


\se{Исходный код}
\noindent
Файлы \textbf{Figure.hpp, Triangle.\{h,c\}pp, Sqr.\{h,c\}pp, Rectangle.\{h,c\}pp} Идентичны таковым в предыдущей лабораторной работе
\lst{lab03}{TTree.hpp}
\lst{lab03}{TTree.cpp}
\lst{lab03}{Tree.hpp}
\lst{lab03}{Tree.cpp}
\lst{lab03}{main.cpp}

\se{Демо}

{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + side_a side_b side_c
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*

command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
________________________________________________
(1,2,2)
command>> ________________________________________________
    (2,4)
(1,2,2)<
command>> ________________________________________________
    (2,4)<
        (2)
(1,2,2)<
command>> ________________________________________________
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ________________________________________________
        (3)
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ________________________________________________
        (3)
    (2,4)<
        (2)<
            (2,1)
(1,2,2)<
    (1,1,1)
command>> -l
________________________________________________
        (3)
    (2,4)<
        (2)<
            (1,2)
    (2,1)<
(1,2,2)<
command>> - r
________________________________________________
        (3)<
    (2)<
            (1,2)
        (2,1)<
(1,2,2)<
command>> - r
________________________________________________
        (2)<
            (1,2)
    (2,1)<
(1,2,2)<
command>> -rlrlr
________________________________________________
        (2)<
            (1,2)
    (2,1)<
(1,2,2)<
command>> -rl
________________________________________________
    (2)<
        (1,2)
(1,2,2)<
command>> 
\end{lstlisting}}

\se{Выводы}


Шаблонные классы очень удобны для создания собственных контейнеров, ведь нам
не важно, что будет лежать в нём, это никак не влияет на реализацию. Однако за такую возможность приходится платить уменьшением читабельности кода и повышением времени компиляции. Хоть это и
сильно сокращает количество кода. К тому же механизм шаблонов в C++ позволяет нам пользоваться
C++ как функциональным языком программирования.

\ttitle{5}

\var

\se{Цель работы}

\begin{itemize}
	\item  Закрепление навыков работы с шаблонами классов.
	\item  Построение итераторов для динамических структур данных.


\end{itemize}


\se{Исходный код}
\noindent
Файлы \textbf{Figure.hpp, Triangle.\{h,c\}pp, Sqr.\{h,c\}pp, Rectangle.\{h,c\}pp} Идентичны таковым в предыдущей лабораторной работе
\lst{lab04}{TIterator.hpp}
\lst{lab04}{TTree.hpp}
\lst{lab04}{TTree.h}
\lst{lab04}{Tree.hpp}
\lst{lab04}{Tree.h}
\lst{lab04}{main.cpp}

\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + side_a side_b side_c
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*

command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
(1,2,2)
command>> ____________________________________________
    (2,4)
(1,2,2)<
command>> ____________________________________________
    (2,4)<
        (2)
(1,2,2)<
command>> ____________________________________________
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)<
            (2,1)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)<
                (1,2)
            (2,1)<
(1,2,2)<
    (1,1,1)
command>> 
g l
____________________________________________
(1,1,1)    Square = 0.433013
command>> g rllr
____________________________________________
(1,2)    Square = 2
command>> s
Show:
(1,1,1)->(1,2,2)->(2,1)->(1,2)->(2)->(2,4)->(3)->nullptr
command>> - l
____________________________________________
        (3)
    (2,4)<
        (2)<
                (1,2)
            (2,1)<
(1,2,2)<
command>> - l
____________________________________________
    (3)<
        (2)<
                (1,2)
            (2,1)<
(2,4)<
command>> 
\end{lstlisting}}

\se{Выводы}

Итераторы для контейнеров могут послужить интерфейсом между программистом и
контейнером, с их помощью можно проходить по контейнеру и получать информацию,
или же изменять контейнер, например с помощью итераторов вставки, и удаления.
Итераторы облегчают код, когда нам нужно пройти по всему контейнеру. Например в
сложных отсортированных структурах, как бинарное дерево, он может быть полезен,
чтобы последовательно выгрузить всю отсортированную информацию.

\ttitle{5}

\var

\se{Цель работы}

\begin{itemize}
	\item   Закрепление навыков по работе с памятью в C++.
	\item Создание аллокаторов памяти для динамических структур данных.


\end{itemize}

\se{Исходный код}

\noindent
Файлы \textbf{Figure.hpp, Triangle.\{h,c\}pp, Sqr.\{h,c\}pp, Rectangle.\{h,c\}pp,}\\ \textbf{TIterator.hpp} Идентичны таковым в предыдущей лабораторной работе

\lst{lab05}{TAllocationBlock.hpp}
\lst{lab05}{TAllocationBlock.cpp}
\lst{lab05}{TTree.hpp}
\lst{lab05}{Tree.hpp}
\lst{lab05}{Tree.h}
\lst{lab05}{main.cpp}

\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + {elem_type} {sides}
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*
Show container:     s

command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
(1,2,2)
command>> ____________________________________________
    (2,4)
(1,2,2)<
command>> ____________________________________________
    (2,4)<
        (2)
(1,2,2)<
command>> ____________________________________________
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)<
            (2,1)
(1,2,2)<
    (1,1,1)
command>> ____________________________________________
        (3)
    (2,4)<
        (2)<
                (1,2)
            (2,1)<
(1,2,2)<
    (1,1,1)
command>> s
Show:
(1,1,1)->(1,2,2)->(2,1)->(1,2)->(2)->(2,4)->(3)->nullptr
command>> ==9584== 
==9584== HEAP SUMMARY:
==9584==     in use at exit: 0 bytes in 0 blocks
==9584==   total heap usage: 36 allocs, 36 frees, 2,487,856 bytes allocated
==9584== 
==9584== All heap blocks were freed -- no leaks are possible

\end{lstlisting}}

\se{Выводы}


Аллокаторы используются для оптимизации выделения памяти. Они позволяют минимизировать вызов оператора new и функции malloc, что увеличивает производительность программы. Лабораторная была интересной, но на практике создание аллокаторов необходимо только в очень специфичных ситуациях, на практике проще и разумнее использовать стандартные средства языка для выделения памяти.


\ttitle{7}
\var

\se{Цель работы}
\begin{itemize}
	\item  Создание сложных динамических структур данных.
	\item Закрепление принципа OCP.
\end{itemize}

\se{Исходный код}
\noindent
Файлы \textbf{TIterator.hpp, TAllocationBlock.\{h,c\}pp} Идентичны таковым в предыдущей лабораторной работе

В файлы фигур были внесены небольшие изменения, в частности добавление функции, возвращающей энумератор, определяющий тип фигуры.

\lst{lab06/release}{Queue.hpp}
\lst{lab06/release}{TTree.hpp}
\lst{lab06/release}{Tree.hpp}
\lst{lab06/release}{Tree.h}
\lst{lab06/release}{main.cpp}

\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + {elem_type} {sides}
Delete element:     - path 
path={r,l}*
Delete by criteria: c
and select avaliable criteria
Get element:        g path
path={r,l}*
Show container:     s

command>> 
+ t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
[(1,2,2)]
command>> ____________________________________________
[(1,2,2),(2,4)]
command>> ____________________________________________
[(1,2,2),(2,4),(2)]
command>> ____________________________________________
[(1,2,2),(2,4),(2),(1,1,1)]
command>> ____________________________________________
[(1,2,2),(2,4),(2),(1,1,1),(3)]
command>> ____________________________________________
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1)]
command>> ____________________________________________
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
[(2,1),(1,2)]
command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1),(1,2),(1,2,2)]
command>> ____________________________________________
    [(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1),(1,2),(1,2,2)]
command>> ____________________________________________
        [(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1),(1,2),(1,2,2),(2)]
command>> ____________________________________________
    [(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]
command>> ____________________________________________
    [(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]
command>> ____________________________________________
    [(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
command>> ____________________________________________
    [(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
    [(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2)]
command>> ____________________________________________
    [(2,4),(3),(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2)]
command>> ____________________________________________
    [(2,4),(3),(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2),(2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2)]
command>> ____________________________________________
    [(2,4),(3),(2,4)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2),(2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> ____________________________________________
    [(2,4),(3),(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2),(2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> ____________________________________________
    [(2,4),(3),(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2),(2),(2,1)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> ____________________________________________
    [(2,4),(3),(2,4),(3)]
[(1,2,2),(2,4),(2),(1,1,1),(3)]<
        [(2,1),(1,2),(2),(2,1),(1,2)]
    [(2,1),(1,2),(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> c
To remove by type press t
To remove by value press v
Your choice: t
Enter fig type (0 = triangle, 1 = square, 2 = rectangle): 2
____________________________________________
    [(3),(3)]
[(1,2,2),(2),(1,1,1),(3)]<
        [(2)]
    [(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> c
To remove by type press t
To remove by value press v
Your choice: v
Enter remove value(double): 8
____________________________________________
[(1,2,2),(2),(1,1,1)]<
        [(2)]
    [(1,2,2),(2),(1,1,1)]<
        [(1,2,2),(1,1,1)]
command>> 
\end{lstlisting}}

\se{Выводы}

В данной лабораторной работе я закрепил навыки работы с памятью на языке С++,
получил навыки создания сложных динамических структур. Применил на практике
принцип ОСP. Создал сложное хранилище данных, автосортируемое по площади, с
возможностью удаления по критериям. Самым сложным было корректно интегрировать один контейнер в другой, так как он имел не все методы.

\ttitle{8}

\var

\se{Цель работы}
Знакомство с параллельным программированием в C++.

\se{Исходный код}
\noindent
Файлы \textbf{Figure.hpp, Triangle.\{h,c\}pp, Sqr.\{h,c\}pp, Rectangle.\{h,c\}pp,}\\ \textbf{TIterator.hpp, TAllocationBlock.\{h,c\}pp} Идентичны таковым в 6 лабораторной работе

\lst{lab07}{TTree.hpp}
\lst{lab07}{Tree.hpp}
\lst{lab07}{Tree.h}
\lst{lab07}{main.cpp}

\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:        + {elem_type} {sides}
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*
Show container:     s

Sort container:     %

command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
(1,2,2)
command>> ____________________________________________
    (2,4)
(1,2,2)<
command>> ____________________________________________
    (2,4)
(1,2,2)<
    (2)
command>> ____________________________________________
        (1,1,1)
    (2,4)<
(1,2,2)<
    (2)
command>> ____________________________________________
        (1,1,1)
    (2,4)<
(1,2,2)<
        (3)
    (2)<
command>> ____________________________________________
        (1,1,1)
    (2,4)<
        (2,1)
(1,2,2)<
        (3)
    (2)<
command>> ____________________________________________
        (1,1,1)
    (2,4)<
        (2,1)
(1,2,2)<
        (3)
    (2)<
        (1,2)
command>> %
Sort:
Usual sort:    u
Parallel sort:    p
u
0.433013 0.968246 2 2 4 8 9 
____________________________________________
        (3)
    (2,4)<
        (2)<
                (1,2)
            (2,1)<
(1,2,2)<
    (1,1,1)
command>> 

================================================
Usage:
Add element:        + {elem_type} {sides}
Delete element:     - path 
path={r,l}*
Get element:        g path
path={r,l}*
Show container:     s

Sort container:     %

command>> + t 1 2 2 + r 2 4 + s 2 + t 1 1 1 + s 3 + r 2 1 + r 1 2
____________________________________________
(1,2,2)
command>> ____________________________________________
    (2,4)
(1,2,2)<
command>> ____________________________________________
    (2,4)
(1,2,2)<
    (2)
command>> ____________________________________________
        (1,1,1)
    (2,4)<
(1,2,2)<
    (2)
command>> ____________________________________________
        (1,1,1)
    (2,4)<
(1,2,2)<
        (3)
    (2)<
command>> ____________________________________________
        (1,1,1)
    (2,4)<
        (2,1)
(1,2,2)<
        (3)
    (2)<
command>> ____________________________________________
        (1,1,1)
    (2,4)<
        (2,1)
(1,2,2)<
        (3)
    (2)<
        (1,2)
command>> %
Sort:
Usual sort:    u
Parallel sort:    p
u
0.433013 0.968246 2 2 4 8 9 
____________________________________________
        (3)
    (2,4)<
            (2)<
                (1,2)
        (2,1)<
(1,2,2)<
    (1,1,1)
command>> 

\end{lstlisting}
}

\se{Выводы}
C++ представляет удобные инструменты для распараллеливания кода, но нужно понимать что такой подход нужен не везде, например как я убедился из лабораторной
работы, на вызов новых потоков при маленьких количествах данных, тратится куда
больше времени, чем если бы мы сортировали контейнер обычной сортировкой.

\ttitle{9}

\var

\se{Цель работы}
Знакомство с лямбда-выражениями

\se{Исходный код}
\noindent
Файлы \textbf{Figure.hpp, Triangle.\{h,c\}pp, Sqr.\{h,c\}pp, Rectangle.\{h,c\}pp,}\\ \textbf{TIterator.hpp, TAllocationBlock.\{h,c\}pp, TTree.hpp, Tree.{h,}pp} Идентичны таковым в 6 лабораторной работе

\lst{lab08}{main.cpp}

\newpage
\se{Демо}
{\scriptsize
	\begin{lstlisting}
Usage:
Add element:   	 + {elem_type} {sides}
Delete element:	 - path 
path={r,l}*
Get element:   	 g path
path={r,l}*
Show container:	 s
Command: c

command>> c
Choose command: 
[R]andom generator
[D]elete by value
[P]rint container
Your choice: R
Random generator
Enter number of elements: 3
____________________________________________
	(1957747793,424238335)
(846930886,1681692777)<
	(1649760492,596516649)
command>> + t 1 1 1
____________________________________________
		(1,1,1)
	(1957747793,424238335)<
(846930886,1681692777)<
	(1649760492,596516649)
command>> c
Choose command: 
[R]andom generator
[D]elete by value
[P]rint container
Your choice: D
Delete by value
Enter value:  10
____________________________________________
	(1957747793,424238335)
(846930886,1681692777)<
	(1649760492,596516649)
command>> P
c
Choose command: 
[R]andom generator
[D]elete by value
[P]rint container
Your choice: P
Show:
(1649760492,596516649)->(846930886,1681692777)->(1957747793,424238335)->nullptr
____________________________________________
	(1957747793,424238335)
(846930886,1681692777)<
	(1649760492,596516649)
command>> Show:
(1540383426,304089172,1303455736)->(468703135,1101513929)->(1649760492,596516649)->
(1059961393,2089018456,628175011)->(1102520059)->(1726956429,336465782,861021530)->
(846930886,1681692777)->(1967513926)->(233665123)->(1957747793,424238335)->
(1315634022,635723058,1369133069)->(1025202362,1350490027)->(521595368)->nullptr
Show:
(1540383426,304089172,1303455736)->(468703135,1101513929)->(1649760492,596516649)->
(1059961393,2089018456,628175011)->(1102520059)->(1726956429,336465782,861021530)->
(846930886,1681692777)->(1967513926)->(233665123)->(1957747793,424238335)->
(1315634022,635723058,1369133069)->(1025202362,1350490027)->(521595368)->nullptr
\end{lstlisting}}

\se{Выводы}

Лямбда-выражения удобны, и часто используются в коде на C++: один из примеров:
std::sort, где третьим аргументом передается компаратор, он может быть представлен
в виде лямбда-функции, таким образом мы можем в конкретном месте выбирать, как
мы будем сортировать наш контейнер.


\end{document}